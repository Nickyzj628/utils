// @bun
var Y=(...x)=>{console.log(`${new Date().toLocaleTimeString()}`,...x)};var f=(x,$=-1)=>{let H=new Map,W=(...m)=>{let D=JSON.stringify(m),I=Date.now(),F=H.get(D);if(F&&I<F.expiresAt)return F.value;let z=$===-1?1/0:I+$*1000,V={setTtl:(M)=>z=I+M*1000},K=x.apply(V,m);if(K instanceof Promise){let M=K.then((X)=>{return H.set(D,{value:X,expiresAt:z}),X});return H.set(D,{value:M,expiresAt:z}),M}return H.set(D,{value:K,expiresAt:z}),K};return W.clear=()=>H.clear(),W.updateTtl=(m)=>{$=m;let D=Date.now(),I=D+m*1000;for(let[F,z]of H.entries())if(z.expiresAt>D)z.expiresAt=I,H.set(F,z)},W};var J=(x)=>{return x?.constructor===Object},N=(x)=>{return x===null||x===void 0||typeof x!=="object"&&typeof x!=="function"};var Q=(x,$)=>{let H={...x};for(let W of Object.keys($)){let m=H[W],D=$[W];if(N(m)&&N(D)){H[W]=D;continue}if(Array.isArray(m)&&Array.isArray(D)){H[W]=m.concat(D);continue}if(J(m)&&J(D)){H[W]=Q(m,D);continue}H[W]=D}return H};var L=(x="",$={})=>{let H=async(W,m={})=>{let D=x?`${x}${W}`:W,{parser:I,...F}=Q($,m);if(J(F.body))F.body=JSON.stringify(F.body),F.headers={...F.headers,"Content-Type":"application/json"};let z=await fetch(D,F);if(!z.ok)throw Error(z.statusText);return await(I?.(z)??z.json())};return{get:(W,m={})=>H(W,{...m,method:"GET"}),post:(W,m,D={})=>H(W,{...D,method:"POST",body:m}),put:(W,m,D={})=>H(W,{...D,method:"PUT",body:m}),delete:(W,m={})=>H(W,{...m,method:"DELETE"})}},T=async(x)=>{try{return[null,await x]}catch($){return[$,void 0]}};var g=(x)=>{return x.replace(/_([a-zA-Z])/g,($,H)=>H.toUpperCase())},q=(x)=>{return x.replace(/([A-Z])/g,($,H)=>`_${H.toLowerCase()}`)};var S=async(x=150)=>{return new Promise(($)=>{setTimeout($,x)})};export{f as withCache,T as to,Y as timeLog,g as snakeToCamel,S as sleep,Q as mergeObjects,N as isPrimitive,J as isObject,L as fetcher,q as camelToSnake};
