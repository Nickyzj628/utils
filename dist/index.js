// @bun
var z=(c)=>{return c?.constructor===Object};class V{cache;maxSize;constructor(c=10){this.cache=new Map,this.maxSize=c}get(c){let a=this.cache.get(c);if(!a)return;return this.cache.delete(c),this.cache.set(c,a),a}set(c,a){if(this.cache.has(c))this.cache.delete(c);else if(this.cache.size>=this.maxSize){let f=[...this.cache.keys()][0];if(f)this.cache.delete(f)}this.cache.set(c,a)}has(c){return this.cache.has(c)}}var g=V;var S=new g,B=(c="")=>{let a=async(f,h={})=>{let e=c?`${c}${f}`:f;if(z(h.body))h.body=JSON.stringify(h.body),h.headers={...h.headers,"Content-Type":"application/json"};let v=()=>fetch(e,h),K;if(!(h.method==="GET"||!h.method))K=v();else{let x=S.get(e);if(!x)x=v(),S.set(e,x);K=x}let d=(await K).clone();if(!d.ok)throw Error(d.statusText);return await d.json()};return{get:(f,h={})=>a(f,{...h,method:"GET"}),post:(f,h,e={})=>a(f,{...e,method:"POST",body:h}),put:(f,h,e={})=>a(f,{...e,method:"PUT",body:h}),delete:(f,h={})=>a(f,{...h,method:"DELETE"})}},C=async(c)=>{try{return[null,await c]}catch(a){return[a,void 0]}};export{C as to,z as isObject,B as fetcher};
