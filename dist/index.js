// @bun
var E=(...H)=>{console.log(`${new Date().toLocaleTimeString()}`,...H)};var T=async(H,z)=>{let{maxRetries:W=5,shouldStop:x=()=>!0}=z??{};for(let D=0;D<W;D++){let $=await H(D);if(x($))return $}throw Error("\u8D85\u8FC7\u4E86\u6700\u5927\u5FAA\u73AF\u6B21\u6570\uFF08maxRetires\uFF09\u4E14\u672A\u6EE1\u8DB3\u505C\u6B62\u6267\u884C\u6761\u4EF6")};var R=(H,z=-1)=>{let W=new Map,x=(...D)=>{let $=JSON.stringify(D),I=Date.now(),Q=W.get($);if(Q&&I<Q.expiresAt)return Q.value;let C=z===-1?1/0:I+z*1000,M={setTtl:(X)=>{C=I+X*1000}},Y=H.apply(M,D);if(Y instanceof Promise){let X=Y.then((Z)=>{return W.set($,{value:Z,expiresAt:C}),Z});return W.set($,{value:X,expiresAt:C}),X}return W.set($,{value:Y,expiresAt:C}),Y};return x.clear=()=>W.clear(),x.updateTtl=(D)=>{z=D;let $=Date.now(),I=$+D*1000;for(let[Q,C]of W.entries())if(C.expiresAt>$)C.expiresAt=I,W.set(Q,C)},x};var J=(H)=>{return H?.constructor===Object},_=(H)=>{return H===null||H===void 0||typeof H!=="object"&&typeof H!=="function"},S=(H)=>{return!H},K=(H)=>{return!!H},P=(H)=>{return H===null||H===void 0};var G=(H,z)=>{let W={...H};for(let x of Object.keys(z)){let D=W[x],$=z[x];if(_(D)&&_($)){W[x]=$;continue}if(Array.isArray(D)&&Array.isArray($)){W[x]=D.concat($);continue}if(J(D)&&J($)){W[x]=G(D,$);continue}W[x]=$}return W},f=(H,z)=>{if(Array.isArray(H))return H.map((W)=>f(W,z));if(J(H))return Object.keys(H).reduce((x,D)=>{let $=z(D),I=H[D];return x[$]=f(I,z),x},{});return H},q=(H,z)=>{if(Array.isArray(H))return H.map((W,x)=>{if(J(W))return q(W,z);return z(W,x)});if(J(H))return Object.keys(H).reduce((x,D)=>{let $=H[D];if(J($)||Array.isArray($))x[D]=q($,z);else x[D]=z($,D);return x},{});return H};var B=(H="",z={})=>{let W=async(x,D={})=>{let $=new URL(H?`${H}${x}`:x),{params:I,parser:Q,...C}=G(z,D);if(J(I))Object.entries(I).forEach(([X,Z])=>{if(P(Z))return;$.searchParams.append(X,Z.toString())});if(J(C.body))C.body=JSON.stringify(C.body),C.headers={...C.headers,"Content-Type":"application/json"};let M=await fetch($,C);if(!M.ok){if(M.headers.get("Content-Type")?.startsWith("application/json"))throw await M.json();throw Error(M.statusText)}return await(Q?.(M)??M.json())};return{get:(x,D)=>W(x,{...D,method:"GET"}),post:(x,D,$)=>W(x,{...$,method:"POST",body:D}),put:(x,D,$)=>W(x,{...$,method:"PUT",body:D}),delete:(x,D)=>W(x,{...D,method:"DELETE"})}},k=async(H)=>{try{return[null,await H]}catch(z){return[z,void 0]}};var g=(H)=>{return H.replace(/_([a-zA-Z])/g,(z,W)=>W.toUpperCase())},d=(H)=>{return H.replace(/([A-Z])/g,(z,W)=>`_${W.toLowerCase()}`)},c=(H)=>{return H.charAt(0).toUpperCase()+H.slice(1)},j=(H)=>{return H.charAt(0).toLowerCase()+H.slice(1)},v=async(H)=>{if(!H.startsWith("http"))throw Error("\u56FE\u7247\u5730\u5740\u5FC5\u987B\u4EE5http\u6216https\u5F00\u5934");let z="",W=await B().get(H,{parser:($)=>{return z=$.headers.get("Content-Type")||"image/jpeg",$.arrayBuffer()}}),D=Buffer.from(W).toString("base64");return`data:${z};base64,${D}`};var b=async(H=150)=>{return new Promise((z)=>{setTimeout(z,H)})};export{R as withCache,k as to,E as timeLog,g as snakeToCamel,b as sleep,G as mergeObjects,q as mapValues,f as mapKeys,T as loopUntil,K as isTruthy,_ as isPrimitive,J as isObject,P as isNil,S as isFalsy,v as imageUrlToBase64,B as fetcher,j as decapitalize,c as capitalize,d as camelToSnake};
