// @bun
var $=(...h)=>{console.log(`${new Date().toLocaleTimeString()}`,...h)};var C=(h,f=-1)=>{let a=new Map,x=(...c)=>{let K=JSON.stringify(c),z=Date.now(),j=a.get(K);if(j&&z<j.expiresAt)return j.value;let H=h((V)=>f=V,...c);if(H instanceof Promise){let V=H.then((M)=>{return a.set(K,{value:M,expiresAt:Date.now()+f*1000}),M});return a.set(K,{value:V,expiresAt:z+f*1000}),V}return a.set(K,{value:H,expiresAt:z+f*1000}),H};return x.clear=()=>a.clear(),x.updateTtl=(c)=>{f=c;let K=Date.now(),z=K+c*1000;for(let[j,g]of a.entries())if(g.expiresAt>K)g.expiresAt=z,a.set(j,g)},x};var W=(h)=>{return h?.constructor===Object};class v{cache;maxSize;constructor(h=10){this.cache=new Map,this.maxSize=h}get(h){let f=this.cache.get(h);if(!f)return;return this.cache.delete(h),this.cache.set(h,f),f}set(h,f){if(this.cache.has(h))this.cache.delete(h);else if(this.cache.size>=this.maxSize){let a=[...this.cache.keys()][0];if(a)this.cache.delete(a)}this.cache.set(h,f)}has(h){return this.cache.has(h)}}var D=v;var O=new D,X=(h="")=>{let f=async(a,x={})=>{let c=h?`${h}${a}`:a;if(W(x.body))x.body=JSON.stringify(x.body),x.headers={...x.headers,"Content-Type":"application/json"};let K=()=>fetch(c,x),z;if(!(x.method==="GET"||!x.method))z=K();else{let V=O.get(c);if(!V)V=K(),O.set(c,V);z=V}let g=(await z).clone();if(!g.ok)throw Error(g.statusText);return await g.json()};return{get:(a,x={})=>f(a,{...x,method:"GET"}),post:(a,x,c={})=>f(a,{...c,method:"POST",body:x}),put:(a,x,c={})=>f(a,{...c,method:"PUT",body:x}),delete:(a,x={})=>f(a,{...x,method:"DELETE"})}},Y=async(h)=>{try{return[null,await h]}catch(f){return[f,void 0]}};export{C as withCache,Y as to,$ as timeLog,W as isObject,X as fetcher};
