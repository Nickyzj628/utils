// @bun
var E=(...x)=>{console.log(`${new Date().toLocaleTimeString()}`,...x)};var _=(x,z=-1)=>{let H=new Map,W=(...D)=>{let $=JSON.stringify(D),J=Date.now(),I=H.get($);if(I&&J<I.expiresAt)return I.value;let F=z===-1?1/0:J+z*1000,f={setTtl:(X)=>F=J+X*1000},Q=x.apply(f,D);if(Q instanceof Promise){let X=Q.then((B)=>{return H.set($,{value:B,expiresAt:F}),B});return H.set($,{value:X,expiresAt:F}),X}return H.set($,{value:Q,expiresAt:F}),Q};return W.clear=()=>H.clear(),W.updateTtl=(D)=>{z=D;let $=Date.now(),J=$+D*1000;for(let[I,F]of H.entries())if(F.expiresAt>$)F.expiresAt=J,H.set(I,F)},W};var M=(x)=>{return x?.constructor===Object},Y=(x)=>{return x===null||x===void 0||typeof x!=="object"&&typeof x!=="function"};var Z=(x,z)=>{let H={...x};for(let W of Object.keys(z)){let D=H[W],$=z[W];if(Y(D)&&Y($)){H[W]=$;continue}if(Array.isArray(D)&&Array.isArray($)){H[W]=D.concat($);continue}if(M(D)&&M($)){H[W]=Z(D,$);continue}H[W]=$}return H},C=(x,z)=>{if(Array.isArray(x))return x.map((H)=>C(H,z));if(M(x))return Object.keys(x).reduce((W,D)=>{let $=z(D),J=x[D];return W[$]=C(J,z),W},{});return x},G=(x,z)=>{if(Array.isArray(x))return x.map((H,W)=>{if(M(H))return G(H,z);return z(H,W)});if(M(x))return Object.keys(x).reduce((W,D)=>{let $=x[D];if(!Y($))W[D]=G($,z);else W[D]=z($,D);return W},{});return x};var R=(x="",z={})=>{let H=async(W,D={})=>{let $=x?`${x}${W}`:W,{parser:J,...I}=Z(z,D);if(M(I.body))I.body=JSON.stringify(I.body),I.headers={...I.headers,"Content-Type":"application/json"};let F=await fetch($,I);if(!F.ok)throw Error(F.statusText);return await(J?.(F)??F.json())};return{get:(W,D={})=>H(W,{...D,method:"GET"}),post:(W,D,$={})=>H(W,{...$,method:"POST",body:D}),put:(W,D,$={})=>H(W,{...$,method:"PUT",body:D}),delete:(W,D={})=>H(W,{...D,method:"DELETE"})}},K=async(x)=>{try{return[null,await x]}catch(z){return[z,void 0]}};var m=(x)=>{return x.replace(/_([a-zA-Z])/g,(z,H)=>H.toUpperCase())},O=(x)=>{return x.replace(/([A-Z])/g,(z,H)=>`_${H.toLowerCase()}`)};var h=async(x=150)=>{return new Promise((z)=>{setTimeout(z,x)})};export{_ as withCache,K as to,E as timeLog,m as snakeToCamel,h as sleep,Z as mergeObjects,G as mapValues,C as mapKeys,Y as isPrimitive,M as isObject,R as fetcher,O as camelToSnake};
