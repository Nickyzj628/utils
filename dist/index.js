// @bun
var X=(...W)=>{console.log(`${new Date().toLocaleTimeString()}`,...W)};var Z=(W,$=-1)=>{let D=new Map,m=(...x)=>{let H=JSON.stringify(x),F=Date.now(),C=D.get(H);if(C&&F<C.expiresAt)return C.value;let z=$===-1?1/0:F+$*1000,Q={setTtl:(K)=>z=F+K*1000},J=W.apply(Q,x);if(J instanceof Promise){let K=J.then((V)=>{return D.set(H,{value:V,expiresAt:z}),V});return D.set(H,{value:K,expiresAt:z}),K}return D.set(H,{value:J,expiresAt:z}),J};return m.clear=()=>D.clear(),m.updateTtl=(x)=>{$=x;let H=Date.now(),F=H+x*1000;for(let[C,z]of D.entries())if(z.expiresAt>H)z.expiresAt=F,D.set(C,z)},m};var I=(W)=>{return W?.constructor===Object},M=(W)=>{return W===null||W===void 0||typeof W!=="object"&&typeof W!=="function"};var N=(W,$)=>{let D={...W};for(let m of Object.keys($)){let x=D[m],H=$[m];if(M(x)&&M(H)){D[m]=H;continue}if(Array.isArray(x)&&Array.isArray(H)){D[m]=x.concat(H);continue}if(I(x)&&I(H)){D[m]=N(x,H);continue}D[m]=H}return D};var T=(W="",$={})=>{let D=async(m,x={})=>{let H=W?`${W}${m}`:m,{parser:F,...C}=N($,x);if(I(C.body))C.body=JSON.stringify(C.body),C.headers={...C.headers,"Content-Type":"application/json"};let z=await fetch(H,C);if(!z.ok)throw Error(z.statusText);return await(F?.(z)??z.json())};return{get:(m,x={})=>D(m,{...x,method:"GET"}),post:(m,x,H={})=>D(m,{...H,method:"POST",body:x}),put:(m,x,H={})=>D(m,{...H,method:"PUT",body:x}),delete:(m,x={})=>D(m,{...x,method:"DELETE"})}},L=async(W)=>{try{return[null,await W]}catch($){return[$,void 0]}};var S=async(W=150)=>{return new Promise(($)=>{setTimeout($,W)})};export{Z as withCache,L as to,X as timeLog,S as sleep,N as mergeObjects,M as isPrimitive,I as isObject,T as fetcher};
