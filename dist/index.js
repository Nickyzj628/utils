// @bun
var P=(...x)=>{console.log(`${new Date().toLocaleTimeString()}`,...x)};var E=(x,f=-1)=>{let W=new Map,D=(...H)=>{let $=JSON.stringify(H),I=Date.now(),M=W.get($);if(M&&I<M.expiresAt)return M.value;let C=f===-1?1/0:I+f*1000,Q={setTtl:(X)=>{C=I+X*1000}},Y=x.apply(Q,H);if(Y instanceof Promise){let X=Y.then((Z)=>{return W.set($,{value:Z,expiresAt:C}),Z});return W.set($,{value:X,expiresAt:C}),X}return W.set($,{value:Y,expiresAt:C}),Y};return D.clear=()=>W.clear(),D.updateTtl=(H)=>{f=H;let $=Date.now(),I=$+H*1000;for(let[M,C]of W.entries())if(C.expiresAt>$)C.expiresAt=I,W.set(M,C)},D};var J=(x)=>{return x?.constructor===Object},_=(x)=>{return x===null||x===void 0||typeof x!=="object"&&typeof x!=="function"},L=(x)=>{return!x};var z=(x,f)=>{let W={...x};for(let D of Object.keys(f)){let H=W[D],$=f[D];if(_(H)&&_($)){W[D]=$;continue}if(Array.isArray(H)&&Array.isArray($)){W[D]=H.concat($);continue}if(J(H)&&J($)){W[D]=z(H,$);continue}W[D]=$}return W},B=(x,f)=>{if(Array.isArray(x))return x.map((W)=>B(W,f));if(J(x))return Object.keys(x).reduce((D,H)=>{let $=f(H),I=x[H];return D[$]=B(I,f),D},{});return x},G=(x,f)=>{if(Array.isArray(x))return x.map((W,D)=>{if(J(W))return G(W,f);return f(W,D)});if(J(x))return Object.keys(x).reduce((D,H)=>{let $=x[H];if(J($)||Array.isArray($))D[H]=G($,f);else D[H]=f($,H);return D},{});return x};var K=(x="",f={})=>{let W=async(D,H={})=>{let $=new URL(x?`${x}${D}`:D),{params:I,parser:M,...C}=z(f,H);if(J(I))Object.entries(I).forEach(([X,Z])=>{$.searchParams.append(X,Z.toString())});if(J(C.body))C.body=JSON.stringify(C.body),C.headers={...C.headers,"Content-Type":"application/json"};let Q=await fetch($,C);if(!Q.ok)throw Error(Q.statusText);return await(M?.(Q)??Q.json())};return{get:(D,H)=>W(D,{...H,method:"GET"}),post:(D,H,$)=>W(D,{...$,method:"POST",body:H}),put:(D,H,$)=>W(D,{...$,method:"PUT",body:H}),delete:(D,H)=>W(D,{...H,method:"DELETE"})}},V=async(x)=>{try{return[null,await x]}catch(f){return[f,void 0]}};var O=(x)=>{return x.replace(/_([a-zA-Z])/g,(f,W)=>W.toUpperCase())},N=(x)=>{return x.replace(/([A-Z])/g,(f,W)=>`_${W.toLowerCase()}`)},g=(x)=>{return x.charAt(0).toUpperCase()+x.slice(1)},h=(x)=>{return x.charAt(0).toLowerCase()+x.slice(1)};var w=async(x=150)=>{return new Promise((f)=>{setTimeout(f,x)})};export{E as withCache,V as to,P as timeLog,O as snakeToCamel,w as sleep,z as mergeObjects,G as mapValues,B as mapKeys,_ as isPrimitive,J as isObject,L as isFalsy,K as fetcher,h as decapitalize,g as capitalize,N as camelToSnake};
