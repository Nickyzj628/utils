// @bun
<<<<<<< Updated upstream
var $=(...h)=>{console.log(`${new Date().toLocaleTimeString()}`,...h)};var C=(h,f=-1)=>{let a=new Map,x=(...c)=>{let K=JSON.stringify(c),z=Date.now(),j=a.get(K);if(j&&z<j.expiresAt)return j.value;let H=h((V)=>f=V,...c);if(H instanceof Promise){let V=H.then((M)=>{return a.set(K,{value:M,expiresAt:Date.now()+f*1000}),M});return a.set(K,{value:V,expiresAt:z+f*1000}),V}return a.set(K,{value:H,expiresAt:z+f*1000}),H};return x.clear=()=>a.clear(),x.updateTtl=(c)=>{f=c;let K=Date.now(),z=K+c*1000;for(let[j,g]of a.entries())if(g.expiresAt>K)g.expiresAt=z,a.set(j,g)},x};var W=(h)=>{return h?.constructor===Object};class v{cache;maxSize;constructor(h=10){this.cache=new Map,this.maxSize=h}get(h){let f=this.cache.get(h);if(!f)return;return this.cache.delete(h),this.cache.set(h,f),f}set(h,f){if(this.cache.has(h))this.cache.delete(h);else if(this.cache.size>=this.maxSize){let a=[...this.cache.keys()][0];if(a)this.cache.delete(a)}this.cache.set(h,f)}has(h){return this.cache.has(h)}}var D=v;var O=new D,X=(h="")=>{let f=async(a,x={})=>{let c=h?`${h}${a}`:a;if(W(x.body))x.body=JSON.stringify(x.body),x.headers={...x.headers,"Content-Type":"application/json"};let K=()=>fetch(c,x),z;if(!(x.method==="GET"||!x.method))z=K();else{let V=O.get(c);if(!V)V=K(),O.set(c,V);z=V}let g=(await z).clone();if(!g.ok)throw Error(g.statusText);return await g.json()};return{get:(a,x={})=>f(a,{...x,method:"GET"}),post:(a,x,c={})=>f(a,{...c,method:"POST",body:x}),put:(a,x,c={})=>f(a,{...c,method:"PUT",body:x}),delete:(a,x={})=>f(a,{...x,method:"DELETE"})}},Y=async(h)=>{try{return[null,await h]}catch(f){return[f,void 0]}};export{C as withCache,Y as to,$ as timeLog,W as isObject,X as fetcher};
=======
var S=(c)=>{return c?.constructor===Object};class j{cache;maxSize;constructor(c=10){this.cache=new Map,this.maxSize=c}get(c){let a=this.cache.get(c);if(!a)return;return this.cache.delete(c),this.cache.set(c,a),a}set(c,a){if(this.cache.has(c))this.cache.delete(c);else if(this.cache.size>=this.maxSize){let x=[...this.cache.keys()][0];if(x)this.cache.delete(x)}this.cache.set(c,a)}has(c){return this.cache.has(c)}}var M=j;var g=new M,I=(c="",a={})=>{let x=async(f,h={})=>{let K=c?`${c}${f}`:f;if(S(h.body))h.body=JSON.stringify(h.body),h.headers={...a.headers,...h.headers,"Content-Type":"application/json"};let V=()=>fetch(K,h),d=h.method==="GET"||!h.method,v;if(!d)v=V();else{let e=g.get(K);if(!e)e=V(),g.set(K,e);v=e}let z=(await v).clone();if(!z.ok)throw Error(z.statusText);return await z.json()};return{get:(f,h={})=>x(f,{...h,method:"GET"}),post:(f,h,K={})=>x(f,{...K,method:"POST",body:h}),put:(f,h,K={})=>x(f,{...K,method:"PUT",body:h}),delete:(f,h={})=>x(f,{...h,method:"DELETE"})}},J=async(c)=>{try{return[null,await c]}catch(a){return[a,void 0]}};export{J as to,S as isObject,I as fetcher};
>>>>>>> Stashed changes
