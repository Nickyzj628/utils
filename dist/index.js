// @bun
var G=(...x)=>{console.log(`${new Date().toLocaleTimeString()}`,...x)};var P=(x,C=-1)=>{let W=new Map,D=(...H)=>{let $=JSON.stringify(H),J=Date.now(),I=W.get($);if(I&&J<I.expiresAt)return I.value;let F=C===-1?1/0:J+C*1000,_={setTtl:(X)=>F=J+X*1000},Q=x.apply(_,H);if(Q instanceof Promise){let X=Q.then((f)=>{return W.set($,{value:f,expiresAt:F}),f});return W.set($,{value:X,expiresAt:F}),X}return W.set($,{value:Q,expiresAt:F}),Q};return D.clear=()=>W.clear(),D.updateTtl=(H)=>{C=H;let $=Date.now(),J=$+H*1000;for(let[I,F]of W.entries())if(F.expiresAt>$)F.expiresAt=J,W.set(I,F)},D};var M=(x)=>{return x?.constructor===Object},Y=(x)=>{return x===null||x===void 0||typeof x!=="object"&&typeof x!=="function"},L=(x)=>{return!x};var Z=(x,C)=>{let W={...x};for(let D of Object.keys(C)){let H=W[D],$=C[D];if(Y(H)&&Y($)){W[D]=$;continue}if(Array.isArray(H)&&Array.isArray($)){W[D]=H.concat($);continue}if(M(H)&&M($)){W[D]=Z(H,$);continue}W[D]=$}return W},z=(x,C)=>{if(Array.isArray(x))return x.map((W)=>z(W,C));if(M(x))return Object.keys(x).reduce((D,H)=>{let $=C(H),J=x[H];return D[$]=z(J,C),D},{});return x},B=(x,C)=>{if(Array.isArray(x))return x.map((W,D)=>{if(M(W))return B(W,C);return C(W,D)});if(M(x))return Object.keys(x).reduce((D,H)=>{let $=x[H];if(!Y($))D[H]=B($,C);else D[H]=C($,H);return D},{});return x};var m=(x="",C={})=>{let W=async(D,H={})=>{let $=x?`${x}${D}`:D,{parser:J,...I}=Z(C,H);if(M(I.body))I.body=JSON.stringify(I.body),I.headers={...I.headers,"Content-Type":"application/json"};let F=await fetch($,I);if(!F.ok)throw Error(F.statusText);return await(J?.(F)??F.json())};return{get:(D,H={})=>W(D,{...H,method:"GET"}),post:(D,H,$={})=>W(D,{...$,method:"POST",body:H}),put:(D,H,$={})=>W(D,{...$,method:"PUT",body:H}),delete:(D,H={})=>W(D,{...H,method:"DELETE"})}},K=async(x)=>{try{return[null,await x]}catch(C){return[C,void 0]}};var O=(x)=>{return x.replace(/_([a-zA-Z])/g,(C,W)=>W.toUpperCase())},h=(x)=>{return x.replace(/([A-Z])/g,(C,W)=>`_${W.toLowerCase()}`)},N=(x)=>{return x.charAt(0).toUpperCase()+x.slice(1)},g=(x)=>{return x.charAt(0).toLowerCase()+x.slice(1)};var w=async(x=150)=>{return new Promise((C)=>{setTimeout(C,x)})};export{P as withCache,K as to,G as timeLog,O as snakeToCamel,w as sleep,Z as mergeObjects,B as mapValues,z as mapKeys,Y as isPrimitive,M as isObject,L as isFalsy,m as fetcher,g as decapitalize,N as capitalize,h as camelToSnake};
